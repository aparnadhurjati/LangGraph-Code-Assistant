from typing import TypedDict
from openai import OpenAI
import tempfile
import os
from utils import has_function_def, clean_code
import importlib.util
import json

#State
# Define the state
class State(TypedDict):
    problem: str
    code: str
    tests_passed: bool
    output: str
    doc_output: str
    tests: str
    func_name: str

#Model
class SimpleOpenAIModel:
    def __init__(self, model_name: str, temperature: float = 0.2):
        self.client = OpenAI()
        self.model_name= model_name
        self.temperature = temperature

    def generate(self, prompt: str) -> str:
        resp = self.client.chat.completions.create(
            model=self.model_name,
            temperature=self.temperature,
            messages=[{"role": "user", "content":prompt}]
        )
        return resp.choices[0].message.content

coder_llm = SimpleOpenAIModel(model_name="gpt-4o", temperature=0.2)
#Agents

""" Generates code using LLM"""
def coder_agent(state: State) -> State:
    problem = state["problem"]
    func_name = state["func_name"]
    prompt = f'You are a Python coder. Write a Python function named {func_name} that solves the following problem:\n"{problem}\nOnly output the code. Write only valid Python code. Do not include markdown fences (```). Do not include explanations or comments.'
    code = coder_llm.generate(prompt)
    state["code"] = code
    return state


""" Generates test cases using LLM """
def test_generator_agent(state: State) -> State:
    problem = state["problem"]
    func_name = state["func_name"]
    prompt = f"""
    You are a Python test generator.
    Generate 3-5 simple unit tests for the function '{func_name}' described below.
    RITICAL REQUIREMENTS:
    - Each test must have DIFFERENT input values that test different scenarios
    - For classification functions (like ROC AUC), ensure y_true contains AT LEAST 2 different classes
    - For numeric functions, test edge cases (0, negative numbers, large numbers)
    - For string functions, test empty strings, special characters, long strings
    
    Test format (JSON only):
    [
        {{
            "func_name": "{func_name}",
            "input": [arg1, arg2, ...],
            "expected": expected_output
        }}
    ]
    
    Problem: {problem}
    
    IMPORTANT: 
    - y_true must have both 0s and 1s for binary classification
    - y_pred should be probabilities between 0 and 1
    - Test edge cases and boundary conditions
    - Ensure tests are diverse and meaningful

    Respond ONLY in JSON format as a Python list of dictionaries.
    Do not include markdown fences (```). Do not include explanations or comments.
    """
    response = coder_llm.generate(prompt)
    print(response)

    try:
        tests = json.loads(response)
        state["tests"] = tests
    except Exception:
        # fallback in case of parse error
        state["tests"] = []

    return state



""" Tests the code generated by the coder_agent using the test cases generated by the test_generator_agent"""
def tester_agent(state: State) -> State:

    code = state["code"]
    code = clean_code(code)  # cleanse the code
    state["code"] = code      # store cleaned code
    tests = state["tests"]
    func_name = state["func_name"]

    if not code or not tests:
        state["tests_passed"] = False
        state["output"] = "No code or tests available."
        return state
    #  AST check
    if not has_function_def(code, func_name):
        state["tests_passed"] = False
        state["output"] = f"Test failed. Function {func_name} not found."
        return state

    with tempfile.NamedTemporaryFile(delete=False, suffix=".py", mode="w") as f:
        f.write(code)
        temp_file = f.name
    

    try:
        spec = importlib.util.spec_from_file_location("generated_code", temp_file)
        mod = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(mod)

        all_passed = True
        errors = []

        for test in tests:
            fn_name = test["func_name"]
            func_args = test["input"]
            expected = test["expected"]

            func = getattr(mod, fn_name, None)
            if func is None:
                all_passed = False
                errors.append(f"Function {fn_name} not found.")
                continue
            try:
                result = func(*func_args)
                assert result == expected, f"Expected {expected}, got {result}"
            except Exception as e:
                all_passed = False
                errors.append(str(e))
            

        if all_passed:
            save_path="output/"+ func_name + ".py"
            with open(save_path, "w") as f:
                f.write(code)
            state["tests_passed"] = True
            state["output"] = f"All tests passed. Code saved to {save_path}."
        else:
            state["tests_passed"] = False
            state["output"] = " | ".join(errors)
    finally:
        # Cleanup temporary files
        os.remove(temp_file)
    return state


""" Generates doc using LLM """
def doc_agent(state: State) -> State:

    """Generates a documentation markdown file for the final code."""
    func_name = state["func_name"]
    doc_path="documentation/"+func_name + ".md"
    code = state["code"]
    if not code:
        state["doc_output"] = "No code available to document."
        return state
    
    prompt = f"""
    Write a clear Python documentation (Markdown format) for the following code.
    Include description, input/output, and examples if possible.
    
    Code:
    {code}
    """
    
    doc_text = coder_llm.generate(prompt)
    # Save documentation
    with open(doc_path, "w") as f:
        f.write(doc_text)

    state["doc_output"] = f"Documentation saved to {doc_path}"
    return state
